{"meta":{"title":"RoyCook的个人博客 | 前端 node.js","subtitle":"RoyCook's coding world!","description":"人工智能、计算机、机器学习、linux、程序员","author":"RoyCook","url":"https://roy-cook.tech","root":"/"},"pages":[{"title":"about","date":"2019-04-24T08:37:09.000Z","updated":"2021-06-25T07:44:13.722Z","comments":true,"path":"about/index.html","permalink":"https://roy-cook.tech/about/index.html","excerpt":"","text":""}],"posts":[{"title":"React Native学习大纲","slug":"React Native学习大纲","date":"2021-06-25T07:44:13.720Z","updated":"2021-06-25T07:44:13.720Z","comments":true,"path":"APP/React-Native/posts/41590.html","link":"","permalink":"https://roy-cook.tech/APP/React-Native/posts/41590.html","excerpt":"","text":"react基础https://reactjs.org/tutorial/tutorial.html es2015react nativehttp://facebook.github.io/react-native/docs/0.48/getting-started.html reduxhttp://www.redux.org.cn/ react redux更新数据和页面可用组件immutable-jshttp://facebook.github.io/immutable-js/docs/#/ 页面导航react-navigationreact-native-router-fluxhttp://blog.csdn.net/u011277123/article/details/52510511tab和navigationStack的概念 网络访问axios 支持拦截器 第三方登录react-native-fbsdk app热更新react-native-code-pushcode push 配置流程 https://www.jianshu.com/p/9e3b4a133bcc 消息推送firebasereact-native-fcm app启动页面react-native-splash-screen 和android，ios app启动页面设置 app 自动化测试appiumhttp://note.youdao.com/noteshare?id=a2ec5eacf98abae91891f5574f2c58a4&amp;sub=74D899180CE04FD5880EA6C558C962AC react native已有组件https://github.com/jondot/awesome-react-native","categories":[{"name":"APP","slug":"APP","permalink":"https://roy-cook.tech/categories/APP/"},{"name":"React Native","slug":"APP/React-Native","permalink":"https://roy-cook.tech/categories/APP/React-Native/"}],"tags":[{"name":"APP","slug":"APP","permalink":"https://roy-cook.tech/tags/APP/"},{"name":"React Native","slug":"React-Native","permalink":"https://roy-cook.tech/tags/React-Native/"}]},{"title":"SSL","slug":"SSL","date":"2021-06-25T07:44:13.720Z","updated":"2021-06-25T07:44:13.720Z","comments":true,"path":"WEB安全/SSL/posts/5325.html","link":"","permalink":"https://roy-cook.tech/WEB安全/SSL/posts/5325.html","excerpt":"","text":"什么是SSL Secure Sockets Layer 安全套接层 为Netscape所研发，用以保障在网络上的数据传输安全 一般通用的规格为40 bit安全标准 SSL协议位于TCP/IP协议与各种应用层协议之间 SSL协议分为两层：SSL记录协议（SSL Record Protocol）和 SSL握手协议 （SSL Handshake Protocol）。前者提供数据封装，压缩，加密等基本支持；后者用于传输之前双方的身份认证，协商加密算法，交换加密密钥等 SSL记录协议处于表示层，SSL握手协议会话会话层。所以从网络层级上讲，SSL处于TCP/IP和应用层之间。TCP处于传输层，IP处于网络层。 SSL协议的作用 认证用户和服务器，确保数据发送到之前的客户机和服务器 加密数据以防止数据中途被窃取 维护数据完整性，确保数据在传输过程中不被改变 SSL协议的工作流程服务器认证阶段： 客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接； 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息； 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器； 服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 HTTPS和SSL的关系 HTTPS是应用层协议（其实它并不是一种协议，准确的说），SSL也是应用层协议，但实际上工作在应用层和传输层之间，也就是说，HTTPS实际上是建立在SSL之上的HTTP协议 SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPSHTTPS(全称：Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS的工作原理： 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器; 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端;该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数; 客户端对服务器的证书进行验证(有关验证证书，可以参考数字签名)，并抽取服务器的公用密钥;然后，再产生一个称作pre_master_secret的随机密码串，并使用服务器的公用密钥对其进行加密(参考非对称加/解密)，并将加密后的信息发送给服务器; 客户端与服务器端根据pre_master_secret以及客户端与服务器的随机数值独立计算出加密和MAC密钥(参考DH密钥交换算法)。 客户端将所有握手消息的MAC值发送给服务器; 服务器将所有握手消息的MAC值发送给客户端。 HTTPS的优点与缺点优点： 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器; HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 缺点： 相同网络环境下，HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。此外，HTTPS协议还会影响缓存，增加数据开销和功耗。 HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。 最关键的，SSL 证书的信用链体系并不安全。特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。 SSL的专业证书需要购买，功能越强大的证书费用越高。个人网站、小网站可以选择入门级免费证书。 SSL 证书通常需要绑定 固定IP，为服务器增加固定IP会增加一定费用; HTTPS 连接服务器端资源占用高较高多，相同负载下会增加带宽和服务器投入成本; SSL证书SSL证书是数字证书的一种，类似于驾驶证、护照和营业执照的电子副本。因为配置在服务器上，也称为SSL服务器证书。SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。 SSL数字证书根据可信强度，大概可以分为以下几种： 域名型 SSL 证书（DV SSL） 企业型 SSL 证书（OV SSL） 增强型 SSL 证书（EV SSL） 证书可靠性(真实并可信)验证过程是一个信任链的验证过程，需要明确三点： 浏览器中预置了一些可信根证书； 证书的签名是由上级颁发者的私钥加密的； 信任链的验证终止与一个可信的证书。 SSL免费证书申请及配置 Using Free SSL/TLS Certificates from Let’s Encrypt with NGINX certbot使用说明","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://roy-cook.tech/categories/WEB安全/"},{"name":"SSL","slug":"WEB安全/SSL","permalink":"https://roy-cook.tech/categories/WEB安全/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://roy-cook.tech/tags/SSL/"}]},{"title":"Git","slug":"Git","date":"2021-06-25T07:44:13.719Z","updated":"2021-06-25T07:44:13.719Z","comments":true,"path":"版本控制/Git/posts/25246.html","link":"","permalink":"https://roy-cook.tech/版本控制/Git/posts/25246.html","excerpt":"","text":"Git的使用什么是Git 一个分步式源代码管理工具在一个项目中 凡是由开发人员编写的都是源代码源代码有必要管理起来？让源代码可以被追溯 主要记录每次变更了什么 谁主导了这次变化人为的维护比较麻烦 安装Git git命令行工具基于git的一个客户端软件（提供一个界面去管理源代码) Git服务商 Git不需要有服务器 但可以有服务器 用来同步本地的代码仓库git是一个工具 github是一个网站github网站提供的就是git服务“免费”服务免费服务必须是开源的github.com GITHUB基本使用 提供的是一个GIT服务的提供商 Git 常用命令 1) 远程仓库相关命令检出仓库：$ git clone git://github.com/jquery/jquery.git查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]删除远程仓库：$ git remote rm [name]修改远程仓库：$ git remote set-url –push [name] [newUrl]拉取远程仓库：$ git pull [remoteName] [localBranchName]推送远程仓库：$ git push [remoteName] [localBranchName] *如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：$git push origin test:master // 提交本地test分支作为远程的master分支$git push origin test:test // 提交本地test分支作为远程的test分支 2）分支(branch)操作相关命令查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] *创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)$git symbolic-ref HEAD refs/heads/[name]$rm .git/index$git clean -fdx 3）版本(tag)操作相关命令查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]合并远程仓库的tag到本地：$ git pull origin –tags上传本地tag到远程仓库：$ git push origin –tags创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’ 4) 子模块(submodule)相关操作命令添加子模块：$ git submodule add [url] [path] 如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下删除子模块：（分4步走哦） 1) $ git rm –cached [path] 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 4) 手动删除子模块残留的目录 5）忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如targetbin*.db Git 常用命令git branch 查看本地所有分支git status 查看当前状态git commit 提交git branch -a 查看所有的分支git branch -r 查看本地所有分支git commit -am “init” 提交并且加注释git remote add origin git@xxx.xxx.xxxgit push origin master 将文件给推到服务器上git remote show origin 显示远程库origin里的资源git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联git checkout –track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支devgit merge origin/dev 将分支dev与当前分支进行合并git checkout dev 切换到本地dev分支git remote show 查看远程库git add .git rm 文件名(包括路径) 从git中删除指定文件git clone xxxxxxx.git 从服务器上将代码给拉下来git config –list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m “This is the message describing the commit” 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm –cached a.a 移除文件(只从暂存区中删除)git commit -m “remove” 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff –cached 或 $ git diff –staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来 git remote add origin xxxxxx.gitgit push origin master 将本地项目给提交到服务器中 git pull 本地与服务器端同步 git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranch git fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支du -hs mkdir WebAppcd WebAppgit inittouch READMEgit add READMEgit commit -m ‘first commit’git remote add origin xxxx.gitgit push -u origin master Git常用命令流程图","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://roy-cook.tech/categories/版本控制/"},{"name":"Git","slug":"版本控制/Git","permalink":"https://roy-cook.tech/categories/版本控制/Git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://roy-cook.tech/tags/版本控制/"},{"name":"Git","slug":"Git","permalink":"https://roy-cook.tech/tags/Git/"}]},{"title":"EventLoop","slug":"EventLoop","date":"2021-05-19T07:11:26.000Z","updated":"2021-06-25T07:44:13.718Z","comments":true,"path":"Node-js/posts/34574.html","link":"","permalink":"https://roy-cook.tech/Node-js/posts/34574.html","excerpt":"","text":"Event Loop是什么 event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。 浏览器的Event Loop是在html5的规范中明确定义。 NodeJS的Event Loop是基于libuv实现的。可以参考Node的官方文档以及libuv的官方文档。 libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。 宏队列和微队列 宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括： setTimeout setInterval setImmediate (Node独有) requestAnimationFrame (浏览器独有) I/O UI rendering (浏览器独有) 微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括： process.nextTick (Node独有) Promise Object.observe MutationObserver（注：这里只针对浏览器和NodeJS） ## 浏览器的Event Loop这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程： 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；全局Script代码执行完毕后，调用栈Stack会清空；从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；执行完毕后，调用栈Stack为空；重复第3-7个步骤；重复第3-7个步骤；…… 这里归纳3个重点： 宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空；图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://roy-cook.tech/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://roy-cook.tech/tags/Node-js/"}]},{"title":"H5唤端","slug":"H5唤端","date":"2019-09-12T04:08:03.000Z","updated":"2021-06-25T07:44:13.719Z","comments":true,"path":"APP/posts/14059.html","link":"","permalink":"https://roy-cook.tech/APP/posts/14059.html","excerpt":"","text":"参考资料 H5唤起APP指南(附开源唤端库)NPM包 callapp-libH5唤起APP小结(附开源唤端库)H5唤起APPHTML打开APP &amp; android chrome禁止自动跳转 唤端成功判断逻辑第一种方案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 获取页面隐藏属性的前缀 * 如果页面支持 hidden 属性，返回 &apos;&apos; 就行 * 如果不支持，各个浏览器对 hidden 属性，有自己的实现，不同浏览器不同前缀，遍历看支持哪个 */function getPagePropertyPrefix() &#123; const prefixes = [&apos;webkit&apos;, &apos;moz&apos;, &apos;ms&apos;, &apos;o&apos;]; let correctPrefix; if (&apos;hidden&apos; in document) return &apos;&apos;; prefixes.forEach((prefix) =&gt; &#123; if (`$&#123;prefix&#125;Hidden` in document) &#123; correctPrefix = prefix; &#125; &#125;); return correctPrefix || false;&#125;/** * 判断页面是否隐藏（进入后台） */function isPageHidden() &#123; const prefix = getPagePropertyPrefix(); if (prefix === false) return false; const hiddenProperty = prefix ? `$&#123;prefix&#125;Hidden` : &apos;hidden&apos;; return document[hiddenProperty];&#125;/** * 获取判断页面 显示|隐藏 状态改变的属性 */function getVisibilityChangeProperty() &#123; const prefix = getPagePropertyPrefix(); if (prefix === false) return false; return `$&#123;prefix&#125;visibilitychange`;&#125;/** * 检测是否唤端成功 * @param &#123;function&#125; cb - 唤端失败回调函数 */export function checkOpen(cb, timeout=2000) &#123; const visibilityChangeProperty = getVisibilityChangeProperty(); const timer = setTimeout(() =&gt; &#123; const hidden = isPageHidden(); if (!hidden) &#123; cb(); &#125; &#125;, timeout); if (visibilityChangeProperty) &#123; document.addEventListener(visibilityChangeProperty, () =&gt; &#123; clearTimeout(timer); &#125;); return; &#125; window.addEventListener(&apos;pagehide&apos;, () =&gt; &#123; clearTimeout(timer); &#125;);&#125; 获取判断页面 显示|隐藏 状态改变的属性，可能结果： visibilitychange webkitvisibilitychange mozvisibilitychange msvisibilitychange ovisibilitychange false 获取页面隐藏属性，可能结果： hidden webkitHidden mozHidden msHidden oHidden false timeout间隔后，通过isPageHidden返回值 判断唤起是成功 false代表失败 失败则执行回调 document.hidden document.webkitHidden document.mozHidden document.msHidden document.oHidden false 如果显示|隐藏 状态改变的属性存在1234document.addEventListener(visibilityChangeProperty, () =&gt; &#123; clearTimeout(timer);&#125;); 如果显示|隐藏 状态改变的属性不存在123window.addEventListener(&apos;pagehide&apos;, () =&gt; &#123; clearTimeout(timer);&#125;); 第二种方案 setTimeout / setInterval 设置延时 123456789101112131415161718192021222324252627282930setTimeout浏览器尝试打开URL scheme并记录时间点t1，在2秒计时后，检查当前时间t2如果t2-t1 &gt; 2200ms,说明唤起app成功(唤起app会是浏览器的定时器延后执行)如果t2-t1 &lt; 2200ms,可能没有安装app，可以引导用户进入下载页。let openTime = +new Date();window.location.href = let timer = setTimeout(function () &#123; if ((new Date()) - openTime &lt; 2200) &#123;//加了200ms基准误差 window.location.href = &apos;https://d.douyin.com/2QvJ/&apos;; &#125; if ((new Date()) - openTime &gt; 2200) &#123; clearTimeout(timer); &#125;&#125;, 2000);方案二 setInterval跟setTimeout相似，方法上换成设置一个比较小的时间间隔（例如20ms）运行多次(例如100),比较运行完100次的总耗时与20*100的时间差。逻辑判断同setTimeout。let limit_num = 100;let openTime = +new Date();let timer = setInterval(function () &#123; if (limit_num &gt; 0) &#123; limit_num--; &#125; else &#123; if ((new Date()) - openTime &lt; 2200) &#123;//加了200ms基准误差 window.location.href = &apos;https://d.douyin.com/2QvJ/&apos;; &#125; clearTimeout(timer); &#125;&#125;, 20);","categories":[{"name":"APP","slug":"APP","permalink":"https://roy-cook.tech/categories/APP/"}],"tags":[{"name":"APP","slug":"APP","permalink":"https://roy-cook.tech/tags/APP/"}]},{"title":"前端自动化---Grunt","slug":"前端自动化-Grunt","date":"2019-06-03T14:54:08.000Z","updated":"2021-06-25T07:44:13.720Z","comments":true,"path":"前端自动化/前端工程化/持续集成/posts/860.html","link":"","permalink":"https://roy-cook.tech/前端自动化/前端工程化/持续集成/posts/860.html","excerpt":"","text":"你需要准备的环境 node.js (一) 安装 1npm install grunt --save (二) 配置gruntfile.js 需要修改两处： 12345678910module.exports = () =&gt; &#123; //配置任务 所有插件的配置信息 grunt.initConfig(&#123; // 获取 package.json的信息 pkg:grunt.file.readJSON(package,json); &#125;); // 告诉grunt 当我们在终端输入grunt时 它需要做些什么 grunt.registerTask(&apos;default&apos;,[]);&#125;； (三) grunt相关插件的介绍 grunt官网的插件列表页面 http://www.gruntjs.net/plugins插件很多。。。分为两大类第一类：grunt团队贡献 有“contrib-”前缀 在插件列表中带有*号第二类第三方提供的插件常用的 排名靠前的：contrib-jshint JavaScript语法错误检查contrib-watch 实时监控文件的变化 调用相应的任务重新执行contrib-clean 清空文件 文件夹contrib-uglify 压缩JavaScript代码contrib-copy 复制文件 文件夹contrib-concat 合并多个文件的代码到一个文件中karma 前端自动化测试工具 (四) 使用uglify插件（压缩JavaScript代码） 安装 1npm insatll grunt-contrib-uglify --save-dev 任务： 压缩js文件 step1：在grunt.initConfig方法中配置uglify的配置参数 1234567891011121314151617181920212223module.exports = () =&gt; &#123; //配置任务 所有插件的配置信息 grunt.initConfig(&#123; // 获取 package.json的信息 pkg:grunt.file.readJSON(package,json); // uglify插件的配置信息 uglify: &#123; options: &#123; stripBanners: true, banner: &apos;/*! &lt;%=pkg.name&gt;-&lt;%=pkg.version%&gt;.js &lt;%=grunt.template.tody(&quot;yyyy-mm-dd&quot;)%&gt;*/\\n&apos; &#125;, // options规定允许生成的压缩文件带banner，即在生成压缩文件第一行加一句话说明。注意，其中使用到了pkg获取package.json的内容。 build: &#123; src: &apos;src/test.js&apos;, dest: &apos;build/&lt;%=pkg.name%&gt;-&lt;%pkg.version%&gt;.js.min.js &#125; // build配置源文件和目标文件。src规定了要压缩谁 desc规定了压缩之后会生成谁 注意，这里将目标文件的文件名通过pkg的name和version来命名。 &#125; &#125;); // 告诉grunt 当我们在终端输入grunt时 它需要做些什么 grunt.registerTask(&apos;default&apos;,[]);&#125;； step2:在grunt.initConfig方法之后，要让grunt去加载这一个插件。 123456grunt.initConfig(&#123; ...&#125;);// 告诉grunt我们将使用插件grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); step3: 在grunt命令执行时，要不要立即执行uglify插件？如果要，就写上，否则不写。 12345678grunt.initConfig(&#123; ...&#125;);// 告诉grunt我们将使用插件grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);// 告诉grunt当我们在终端输入grunt时需要做些什么（注意先后次序）grunt.registerTask(&apos;default&apos;,[&apos;uglify&apos;]); 完成 (五) 使用jshint插件（检查JavaScript语法错误） 安装 1npm insatll grunt-contrib-jshint --save-dev 任务：检查当前test.js的语法错误 step1:在grunt.initConfig方法中配置jshint的配置参数 1234567891011121314151617181920212223242526module.exports = () =&gt; &#123; //配置任务 所有插件的配置信息 grunt.initConfig(&#123; // 获取 package.json的信息 pkg:grunt.file.readJSON(package,json); // uglify插件的配置信息 uglify: &#123; ... &#125;, // jshint插件的配置信息 jshint: &#123; build: [&apos;Gruntfile.js&apos;, &apos;src/*.js&apos;], // build描述了jshint要检查哪些js文档的语法 options: &#123; jshint: &apos;.jshintrc&apos; &#125; // options描述了要通过怎么的规则检查语法 // 这些规则的描述文件就保存在网站根目录下的一个叫做“.jshintrc”的文件中 // 在网站的根目录下面添加上这个文档，并且填写上文件内容。 &#125; &#125;); // 告诉grunt 当我们在终端输入grunt时 它需要做些什么 grunt.registerTask(&apos;default&apos;,[]);&#125;； step2:在 grunt.initConfig 方法之后，要让grunt去加载这一个插件。注意没有先后顺序 123// 告诉grunt我们将使用插件 grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;); step3：配置grunt命令启动时，要执行的任务，这里注意先后顺序。是希望先检查语法呢？还是先合并呢？——应该先检查语法比较好，因为语法不对，合并了有什么意义 1grunt.registerTask(&apos;default&apos;,[&apos;jshint&apos;, uglify&apos;]); 完成 (六) 使用csslint插件（检查css语法错误） 安装12npm insatll grunt-contrib-csslint --save-dev// 只不过csslint依赖于一个叫做“.csslintrc”的文件作为语法检验的规则。","categories":[{"name":"前端自动化","slug":"前端自动化","permalink":"https://roy-cook.tech/categories/前端自动化/"},{"name":"前端工程化","slug":"前端自动化/前端工程化","permalink":"https://roy-cook.tech/categories/前端自动化/前端工程化/"},{"name":"持续集成","slug":"前端自动化/前端工程化/持续集成","permalink":"https://roy-cook.tech/categories/前端自动化/前端工程化/持续集成/"}],"tags":[{"name":"前端自动化","slug":"前端自动化","permalink":"https://roy-cook.tech/tags/前端自动化/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://roy-cook.tech/tags/前端工程化/"},{"name":"持续集成","slug":"持续集成","permalink":"https://roy-cook.tech/tags/持续集成/"}]},{"title":"前端自动化---Gulp","slug":"前端自动化-Gulp","date":"2019-06-03T14:54:08.000Z","updated":"2021-06-25T07:44:13.720Z","comments":true,"path":"前端自动化/前端工程化/持续集成/posts/860.html","link":"","permalink":"https://roy-cook.tech/前端自动化/前端工程化/持续集成/posts/860.html","excerpt":"","text":"","categories":[{"name":"前端自动化","slug":"前端自动化","permalink":"https://roy-cook.tech/categories/前端自动化/"},{"name":"前端工程化","slug":"前端自动化/前端工程化","permalink":"https://roy-cook.tech/categories/前端自动化/前端工程化/"},{"name":"持续集成","slug":"前端自动化/前端工程化/持续集成","permalink":"https://roy-cook.tech/categories/前端自动化/前端工程化/持续集成/"}],"tags":[{"name":"前端自动化","slug":"前端自动化","permalink":"https://roy-cook.tech/tags/前端自动化/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://roy-cook.tech/tags/前端工程化/"},{"name":"持续集成","slug":"持续集成","permalink":"https://roy-cook.tech/tags/持续集成/"}]},{"title":"Jenkins + docker + nginx 自动化构建搭建 (一) --- 配置基本环境","slug":"自动化构建1","date":"2019-03-01T03:27:52.000Z","updated":"2021-06-25T07:44:13.721Z","comments":true,"path":"自动化/持续集成/posts/860.html","link":"","permalink":"https://roy-cook.tech/自动化/持续集成/posts/860.html","excerpt":"","text":"你需要准备的环境（这里以阿里云ECS Ubuntu 16.04 为例） 服务器： 阿里云服务器ECS 操作系统: Ubuntu 16.04 (一) 修改阿里云ECS默认主机名 需要修改两处： 1234567vi /etc/hostname&lt;!--将其对应的主机名修改为新的主机名--&gt;vi /etc/hosts&lt;!--需要将 /etc/hosts 中 127.0.0.1 对应的老主机名更换为新的主机名--&gt;&lt;!--重启服务器生效--&gt; 修改完毕后重新 shell 登录即可 (二) 为Ubuntu系统添加新的普通用户 在使用Ubuntu系统的过程中，一般不建议直接使用root用户，建议新建一个或多个普通用户，平时的操作都使用普通用户登录Ubuntu系统。 使用root用户登录Ubuntu系统以后，打开一个终端，在终端中执行如下Shell命令 1sudo useradd -m roy -s /bin/bash 这条命令创建了可以登陆的 linziyu 用户，并使用 /bin/bash 作为 shell 接着使用如下命令为这个新用户设置密码，请按系统提示输入两次密码： 1sudo passwd roy 可为roy 用户增加管理员权限，方便部署，避免一些对新手来说比较棘手的权限问题 1sudo adduser roy sudo 然后，把登录用户从root用户切换到roy用户，命令如下： 1su roy (三) 创建ssh公、私钥 (使用root用户) 1ssh-keygen -t rsa -C &quot;your@email.com&quot; 连续回车三次即可 (四) 安装docker环境 1. 卸载旧版本docker(全新安装时，无需执行该步骤)1sudo apt-get remove docker docker-engine docker.io 2. 更新系统软件1sudo apt-get update 3. 安装依赖包1sudo apt-get install apt-transport-https ca-certificates curl software-properties-common 4. 添加Docker官方的GPG密钥1234curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -&lt;!--显示OK,表示添加成功.--&gt;&lt;!--执行该命令时，如遇到长时间没有响应说明网络连接不到docker网站，需要使用代理进行--&gt; 5. 添加设置stable存储库1sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; 6. 再更新一下apt包索引1sudo apt-get update 7. 再更新一下apt包索引12345sudo apt-get install docker-ce&lt;!--在生产系统上，可能会需要应该安装一个特定版本的Docker CE，而不是总是使用最新版本：--&gt;&lt;!--apt-cache madison docker-ce--&gt; &lt;!--列出可用的版本--&gt;&lt;!--sudo apt-get install docker-ce=&lt;VERSION&gt;--&gt; 8. 验证docker12345678910111213&lt;!--查看docker版本：--&gt;docker -v&lt;!--Docker version 18.06.1-ce, build e68fc7a--&gt; &lt;!--出现类似以上信息代表安装成功--&gt;&lt;!--查看docker服务是否启动：--&gt;systemctl status docker&lt;!--若未启动，则启动docker服务：--&gt;sudo systemctl start docker&lt;!--hello world测试：--&gt;sudo docker run hello-world&lt;!--若是出现Hello from Docker字样代表成功 --&gt; 9. docker-compose安装1234567sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composedocker-compose --version&lt;!--docker-compose version 1.22.0, build f46880fe--&gt;&lt;!--出现上述字样代表安装成功--&gt;","categories":[{"name":"自动化","slug":"自动化","permalink":"https://roy-cook.tech/categories/自动化/"},{"name":"持续集成","slug":"自动化/持续集成","permalink":"https://roy-cook.tech/categories/自动化/持续集成/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://roy-cook.tech/tags/持续集成/"},{"name":"自动化","slug":"自动化","permalink":"https://roy-cook.tech/tags/自动化/"}]},{"title":"Jenkins + docker + nginx 自动化构建搭建 (二) --- 常用软件安装","slug":"自动化构建2","date":"2019-03-01T03:27:52.000Z","updated":"2021-06-25T07:44:13.721Z","comments":true,"path":"自动化/持续集成/posts/14787.html","link":"","permalink":"https://roy-cook.tech/自动化/持续集成/posts/14787.html","excerpt":"","text":"常用镜像安装准备 1. 安装任务列表 应用程序 对应端口映射 （本机：docker容器） jenkins 8080 ： 8080 mysql 3306 ： 3306 mongo 27017 ： 27017 redis 6379 ： 6379 nginx 8765 ： 80 2. 在阿里云后台添加以上应用的安全组信息略 3. 在ECS服务器上创建创建如下目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546cd /homesudo mkdir docker_home&lt;!--这个docker_home文件夹用来存放docker安装的所有应用程序的所有文件--&gt;&lt;!--也就是宿主机上将要映射到容器的宿主机目录 --&gt;&lt;!--比如下面的jenkins目录 之后jenkins的一些配置文件都将会存储到该目录下--&gt;|-- docker_home |-- jenkins | |-- mongo | |-- data | |-- configdb | |-- db | |-- mysql | |-- conf | |-- data | |-- logs | |-- nginx | |-- config | |-- conf.d | |-- default.conf | |-- nginx.conf | |-- logs | |-- ssl | |-- redis | |-- data | |-- adminmongo default.conf nginx.conf两个重要nginx源文件 最好能提前准备好 也可以在docker run 的时候不挂载，成功启动nginx后，通过sudo docker cp [containerId]/etc/nginx/nginx.conf /home/docker_home/nginx/config/nginx.conf 这种形式复制nginx镜像中的源文件到本地相应文件夹 再停止和删除nginx容器（必要的操作）重新docker run 命令挂载但是考虑到这两个文件一般都是有标准模板可以轻易找到 还是自行准备比较好 避免麻烦 (一) ubuntu下安装docker版jenkins 1. 使用下面的命令拉取jenkins的docker镜像，这里我是用的是lts的长期支持版本，你可以到jenkins官网自由选择其他版本12sudo docker search jenkinssudo docker pull jenkins/jenkins:lts 2. 设置宿主机映射目录的所有者和所属的组1sudo chown -R 1000:1000 /home/docker_home/jenkins 3. 启动jenkins的docker镜像，并设置相关参数1234567sudo docker run -d --name jenkins -p 8080:8080 -p 50000:50000 -u root \\ -v /home/docker_home/jenkins:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /usr/bin/docker:/usr/bin/docker \\ -v /usr/lib/x86_64-linux-gnu/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 \\ -v /opt:/opt \\ -v /etc/timezone:/etc/timezone jenkins/jenkins:lts ==-d== 表示以后台模式运行 ==–name== 为容器定义一个名字（后面可以代替容器id使用） ==-p== 表示映射容器的端口到宿主机的端口 ==-u root== 使用root用户运行，避免后面出现的一些执行权限问题 ==-v== 表示映射宿主机的目录到容器的目录 ==-v /home/jenkins_home:/var/jenkins_home== 映射jenkins_home，将数据存储到宿主机，这样配置就不会随容器丢失 ==-v /var/run/docker.sock:/var/run/docker.sock== 与 ==-v /usr/bin/docker:/usr/bin/docker== 把宿主机docker 映射到容器内，可以直接在容器内使用宿主机docker ==-v /usr/lib/x86_64-linux-gnu/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7== 容器内docker运行需要的库文件 ==-v /opt:/opt== 自主安装的一些运行时软件（如java/maven/git…） ==-v /etc/timezone:/etc/timezone== 映射时区文件，保证容器的时区和宿主机相同（官网的jenkins容器时区不是中国的时区） 4. 容器启动后，就可以访问ip:8080看到jenkins首次运行的首页了，然后通过下面命令查看初始密码，填入之后跳转到安装插件的页面，选择第一个就好，会默认安装一些插件1sudo cat /home/docker_home/jenkins/secrets/initialAdminPassword 5. 跳转到创建用户和密码的界面，创建好后，jenkins的安装也就到此结束了(二) ubuntu下安装docker版nginx1. 使用下面的命令拉取nginx的docker镜像12sudo docker search nignxsudo docker pull nginx 2. 启动nignx的docker镜像，并设置相关参数，创建容器 1234567docker run --detach --name nginx -p 80:80 -p 443:443 \\-v /home/docker_home/nginx/data:/usr/share/nginx/html \\-v /home/docker_home/nginx/config/nginx.conf:/etc/nginx/nginx.conf \\-v /home/docker_home/nginx/config/conf.d:/etc/nginx/conf.d \\-v /home/docker_home/nginx/logs:/var/log/nginx \\-v /home/docker_home/nginx/ssl:/ssl \\-d nginx 3. 使用想要进入交互式终端，使用如下命令 1sudo docker exec -it nginx /bin/bash (三) ubuntu下安装docker版mysql 1. 使用下面的命令拉取mysql的docker镜像，我这里安装mysql5.6版本12sudo docker search mysqlsudo docker pull mysql:5.6 2. 启动mysql的docker镜像，并设置相关参数123cd /home/docker_home/mysql/confvi my.cnf&lt;!--wq!保存--&gt; 123456sudo docker run -p 3306:3306 --name mysql \\-v /home/docker_home/mysql/conf/my.cnf:/etc/mysql/my.cnf \\-v /home/docker_home/mysql/logs:/logs \\-v /home/docker_home/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=your_password \\-d mysql:5.6 命令说明： /home/docker_home/mysql/data目录将映射为mysql容器配置的数据文件存放路径 /home/docker_home/mysql/logs目录将映射为mysql容器的日志目录 /home/docker_home/mysql/conf目录里的配置文件将映射为mysql容器的配置文件 ==-p 3306:3306==：将容器的 3306 端口映射到主机的 3306 端口 ==-v -v /home/docker_home/mysql/conf/my.cnf:/etc/mysql/my.cnf==：将主机的 /home/docker_home/mysql/conf/my.cnf挂载到容器的 /etc/mysql/my.cnf文件 ==-v /home/docker_home/mysql/logs==:/logs：将主机/home/docker_home/mysql/logs 目录挂载到容器的 /logs ==-v /home/docker_home/mysql/data:/var/lib/mysql==：将主机/home/docker_home/mysql/data目录挂载到容器的 /var/lib/mysql ==-e MYSQL_ROOT_PASSWORD=123456==：初始化 root 用户的密码 12sudo docker ps&lt;!--存在mysql的容器 运行正常--&gt; 测试 此时便可以在客户端使用shell或者Navicat等工具进行远程访问 3. 进入容器操作12345678sudo docker exec -it mysql env LANG=C.UTF-8 bash&lt;!--其中 env LANG=C.UTF-8 bash 让docker命令行支持中文--&gt;cp /usr/my.cnf /etc/mysql/my.cnfmysql -u root -p 123gogogoshow databases; 4. 退出mysql，退出docker12345678&lt;!--修改my.cnf配置文件--&gt;sudo vi /home/docker_home/mysql/conf/my.cnf&lt;!--加入--&gt;[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8&lt;!--重启mysql容器--&gt;docker restart mysql 5. 添加远程登录用户1234CREATE USER &apos;roy&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123gogogo!&apos;;GRANT ALL PRIVILEGES ON *.* TO &apos;roy&apos;@&apos;%&apos;; (四) ubuntu下安装docker版mongodb 1. 使用下面的命令拉取Docker Hub上的mongo镜像12sudo docker search mongosudo docker pull mongo 2. 启动mongo的docker镜像，并设置相关参数1docker run --name mongo -p 27017:27017 -v /home/docker_home/mongo/data/configdb:/data/configdb -v /home/docker_home/mongo/data/db:/data/db -d mongo --auth 命令说明： ==-p 27017:27017==：将容器的 27017 端口映射到主机的 27017 端口 ==-v /home/docker_home/mongo/data/configdb:/data/configdb==：将宿主机/home/docker_home/mongo/data/configdb目录挂载到容器的/data/configdb ==-v /home/docker_home/mongo/data/db:/data/db==：将宿主机/home/docker_home/mongo/data/db目录挂载到容器的/data/db 12sudo docker ps&lt;!--存在mongo的容器 运行正常--&gt; 测试 此时便可以在客户端使用shell或者MongoChef等工具进行远程访问 3. 进入容器操作1234567891011sudo docker exec -it mongo mongo admindb.createUser(&#123; user: &quot;admin&quot;, pwd: &quot;password&quot;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;);db.auth(&quot;admin&quot;, &quot;password&quot;);use testdb.createUser(&#123; user: &quot;usertest&quot;, pwd: &quot;passwordtest&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125; ] &#125;);db.auth(&quot;usertest&quot;, &quot;passwordtest&quot;); (五) ubuntu下安装docker版redis 1. 使用下面的命令拉取Docker Hub上的redis镜像12sudo docker search redissudo docker pull redis:3.2 2. 启动redis的docker镜像，并设置相关参数1sudo docker run -p 6379:6379 -v /home/docker_home/redis/data:/data -d redis:3.2 redis-server --appendonly yes 命令说明： ==-p 6379:6379==：将容器的 6379 端口映射到主机的 6379 端口 ==-v /home/docker_home/redis/data:/data==：将主机/home/docker_home/mongo/db目录挂载到容器的/data/db ==redis-server==：redis的启动命令 ==–appendonly yes==：打开redis持久化配置 12sudo docker ps&lt;!--存在redis的容器 运行正常--&gt; 测试 此时便可以在客户端使用shell等工具进行远程访问 3. 进入容器操作12345sudo docker rename clever_northcutt redis有可能容器名称不是&apos;redis&apos;，可以通过docker rename 命令进行修改sudo docker exec -it redis redis-cli&lt;!--当然使用[CONTAINER ID]也可以--&gt; (六) ubuntu下安装mongoexpress / adminmongo mongoexpress1. 使用下面的命令拉取Docker Hub上的mongoexpress镜像1docker pull mongo-express 2. 启动mongoexpress的docker镜像，并设置相关参数123456789docker run --link mongo:mongo --name mongoexpress -p 8081:8081 -e ME_CONFIG_BASICAUTH_USERNAME=&quot;root&quot; -e ME_CONFIG_BASICAUTH_PASSWORD=&quot;your_password&quot; -d mongo-expressdocker run --restart=always --name mongoexpress --link mongo:mongo -d -p 8081:8081 \\-e ME_CONFIG_OPTIONS_EDITORTHEME=&quot;3024-night&quot; \\-e ME_CONFIG_BASICAUTH_USERNAME=&quot;basic_username&quot; \\-e ME_CONFIG_BASICAUTH_PASSWORD=&quot;basic_password&quot; \\-e ME_CONFIG_MONGODB_ADMINUSERNAME=&quot;db_username&quot; \\-e ME_CONFIG_MONGODB_ADMINPASSWORD=&quot;db_password&quot; \\mongo-express 命令说明： ==–link mongo:mongo9==：与当前机器上的mongo镜像关联 才能连接到当前服务器上的mongodb 12sudo docker ps&lt;!--存在mongoexpres的容器 运行正常--&gt; adminmongo1. 使用下面的命令拉取Docker Hub上的adminmongo镜像1docker pull mrvautin/adminmongo 2. 启动adminmongo的docker镜像，并设置相关参数1docker run -d -e HOST=0.0.0.0 -e PASSWORD=&quot;your_password&quot; -e LOCALE=&quot;zh-cn&quot; -p 1234:1234 -v /home/docker_home/adminmongo/config:/app/user/config --name=&quot;adminmongo&quot; mrvautin/adminmongo 12sudo docker ps&lt;!--存在mongoexpres的容器 运行正常--&gt; 3. 进入容器操作1sudo docker exec -it adminmongo sh (八) ubuntu下安装Yapi方法一： 使用开源镜像 1. 获取 Yapi 镜像，版本信息可在 阿里云镜像仓库 查看1docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi 2. 初始化 Yapi 数据库索引及管理员账号1234docker run -it --link mongo:mongo --entrypoint npm --workdir /api/vendors registry.cn-hangzhou.aliyuncs.com/anoy/yapi run install-server&lt;!--自定义配置文件挂载到目录 /api/config.json，官方自定义配置文件--&gt;&lt;!--https://github.com/YMFE/yapi/blob/master/config_example.json--&gt; 3. 启动 Yapi 服务1docker run -d --name yapi --link mongo:mongo --workdir /api/vendors -p 8082:3000 registry.cn-hangzhou.aliyuncs.com/anoy/yapi server/app.js 4. 使用 Yapi1&lt;!--访问 http://ip:8082 登录账号 admin@admin.com，密码 ymfe.org--&gt; 方法二： 自己构建镜像（基于Yapi的GitHub项目） 1. 生成一个Yapi项目12npm install -g yapi-cli --registry https://registry.npm.taobao.orgyapi server 2. 在浏览器打开 http://0.0.0.0:9090 访问。非本地服务器，请将 0.0.0.0 替换成指定的域名或ip, 并按需填写其他信息12345初始化管理员账号成功,账号名：&quot;你填写的账户名&quot;，默认密码：&quot;ymfe.org&quot;部署成功，请切换到部署目录，输入： &quot;node vendors/server/app.js&quot; 指令启动服务器, 然后在浏览器打开 http://127.0.0.1:3000 访问测试成功 清空yapi数据库 3. 删除无用文件1234sudo rm -rf .init.lock // 这个是用没有初始化过的标识，因为刚才已经初始化过了，所以必须要删除它，否则制作成镜像并且启动时不会再执行初始化sudo rm -rf log 4. config.json配置可以看到根目录下的config.json中包含了我们刚才在第2步中填写的一些信息，如果有想修改的，可以进行编辑 5. 编写Dockerfile用于构建镜像 比如：1234567891011121314# 设置基础镜像,如果没有该镜像，会从Docker.io服务器pull镜像# 指定我们的基础镜像是node，版本是v10.9.0FROM node:10.9.0# 在服务器根目录下创建/home/service目录RUN mkdir -p /home/service# 相当于 cd 到 /home/service目录WORKDIR /home/service# 拷贝所有源代码到工作目录COPY . /home/service# 暴露容器端口EXPOSE 8082# 启动node应用CMD node vendors/server/install.js &amp; node vendors/server/app.js 其中node vendors/server/install.js这一句就是执行初始化，它会把config.json的配置全部入库到你在config.json中指定的数据库 6. 构建镜像并上传到你的dockerhub(自己注册一个dockerhub账号)12345678910docker build -t [image_name] .docker tag [image_name] [dockerhub_name]/[image_name]:[tag]// 因为要上传到dockerhub必须保持[dockerhub_name]/[image_name]:[tag]的形式 所以这里要docker tag 执行一下// 当然也可以在docker build的时候直接写成这种形式 就不用docker tag了 更省事// docker tag实际上是将原镜像复制一份 再将复制的这份重命名了docker login // 终端登陆dockerhubdocker push [dockerhub_name]/[image_name]:[tag] // 提交到dockerhub 7. 使用镜像12docker pull [dockerhub_name]/[image_name]:[tag]docker run -d --name [container_name] -p 8082:8082 [dockerhub_name]/[image_name]:[tag]","categories":[{"name":"自动化","slug":"自动化","permalink":"https://roy-cook.tech/categories/自动化/"},{"name":"持续集成","slug":"自动化/持续集成","permalink":"https://roy-cook.tech/categories/自动化/持续集成/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"https://roy-cook.tech/tags/持续集成/"},{"name":"自动化","slug":"自动化","permalink":"https://roy-cook.tech/tags/自动化/"}]},{"title":"自行实现一个Promise","slug":"自行实现一个Promise","date":"2018-10-10T09:38:59.000Z","updated":"2021-06-25T07:44:13.721Z","comments":true,"path":"Web前端/JavaScript/posts/61442.html","link":"","permalink":"https://roy-cook.tech/Web前端/JavaScript/posts/61442.html","excerpt":"","text":"实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295// Promise.js&apos;use strict&apos;;const PENDING = &apos;pending&apos;;const FULFILLED = &apos;fulfilled&apos;;const REJECTED = &apos;rejected&apos;;const isFunction = function (target) &#123; return target &amp;&amp; typeof target === &apos;function&apos;;&#125;;const isObject = function (target) &#123; return target &amp;&amp; typeof target === &apos;object&apos;;&#125;;class Promise &#123; constructor (executor) &#123; if (!this || this.constructor !== Promise) &#123; throw new TypeError(&apos;Promise must be called with new&apos;); &#125; if (!isFunction(executor)) &#123; throw new TypeError(`Promise constructor&apos;s argument must be a function`); &#125; this.state = PENDING; this.value = null; this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; const resolve = value =&gt; &#123; resolutionProcedure(this, value); &#125;; const reject = error =&gt; &#123; if (this.state === PENDING) &#123; this.state = REJECTED; this.value = error; this.onRejectedCallbacks.forEach(callback =&gt; callback()); &#125; &#125;; const resolutionProcedure1 = (promise, target) =&gt; &#123; if (promise === target) return reject(new TypeError(&apos;Promise can not resolved with it self&apos;)); // 循环引用 if (target instanceof Promise) return target.then(resolve, reject); if (isObject(target) || isFunction(target)) &#123; let called = false; try &#123; let then = target.then; if (isFunction(then)) &#123; then.call( target, value =&gt; &#123; if (called) return; called = true; resolutionProcedure(promise, value); &#125;, error =&gt; &#123; if (called) return; called = true; reject(error); &#125; ); return; &#125; &#125; catch (error) &#123; if (called) return; called = true; reject(error); &#125; &#125; if (promise.state === PENDING) &#123; promise.state = FULFILLED; promise.value = target; promise.onFulfilledCallbacks.forEach((callback) =&gt; callback()); &#125; &#125;; const resolutionProcedure = (promise, target) =&gt; &#123; if (promise === target) return reject(new TypeError(&apos;Promise can not resolved with it self&apos;)); // 循环引用 if (target instanceof Promise) return target.then(resolve, reject); if (isObject(target) || isFunction(target)) &#123; let called = false; try &#123; let then = target.then; if (isFunction(then)) &#123; then.call( target, value =&gt; &#123; if (called) return; called = true; resolutionProcedure(promise, value); &#125;, error =&gt; &#123; if (called) return; called = true; reject(error); &#125; ); return; &#125; &#125; catch (error) &#123; if (called) return; called = true; reject(error); &#125; &#125; if (promise.state === PENDING) &#123; promise.state = FULFILLED; promise.value = target; promise.onFulfilledCallbacks.forEach(callback =&gt; callback()); &#125; &#125;; try &#123; executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125; then(onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : reason =&gt; &#123; throw reason; &#125;; const newPromise = new Promise((resolve, reject) =&gt; &#123; const wrapOnFulfilledCallback = () =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; resolve(onFulfilled(this.value)); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0); &#125;; const wrapOnRejectedCallback = () =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; resolve(onRejected(this.value)); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0); &#125;; if (this.state === PENDING) &#123; this.onFulfilledCallbacks.push(wrapOnFulfilledCallback); this.onRejectedCallbacks.push(wrapOnRejectedCallback); &#125; else if (this.state === FULFILLED) &#123; wrapOnFulfilledCallback(); &#125; else if (this.state === REJECTED) &#123; wrapOnRejectedCallback(); &#125; &#125;); return newPromise; &#125; catch(onRejected) &#123; return this.then(null, onRejected); &#125; finally(callback) &#123; return this.then( value =&gt; &#123; callback(); return value; &#125;, error =&gt; &#123; callback(); throw error; &#125; ); &#125; done() &#123; return this.catch(error =&gt; &#123; throw error; &#125;); &#125; static resolve(value) &#123; return value instanceof Promise ? value : new Promise(resolve =&gt; resolve(value)); &#125; static reject(reason) &#123; return new Promise((resolve, reject) =&gt; reject(reason)); &#125; static race(promises) &#123; return new Promise ((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; Promise.resolve(promise).then(resolve, reject)); &#125;); &#125; static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; let resolveCount = 0; const len = promises.length; if (!len) &#123; resolve([]); &#125; for (let index = 0; index &lt; len; index++) &#123; Promise.resolve(promises[index]).then( (data) =&gt; &#123; result[index] = data; if (++resolveCount === len) &#123; resolve(result); &#125; &#125;, (error) =&gt; &#123; reject(error); &#125; ); &#125; &#125;); &#125; static allSettled(promises) &#123; return new Promsie((resolve, reject) =&gt; &#123; let result = []; let resolveCount = 0; const len = promises.length; if (!len) &#123; resolve([]); &#125; for (let index = 0; index &lt; len; index++) &#123; Promsie.resolve(promises[index]).then( data =&gt; &#123; result[index] = &#123; status: FULFILLED, value: data, &#125;; if (++resolveCount === len) &#123; resolve(result); &#125; &#125;, error =&gt; &#123; result[index] = &#123; status: REJECTED, value: error, &#125;; if (++resolveCount === len) &#123; resolve(result); &#125; &#125; ); &#125; &#125;); &#125; static defer() &#123; const dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd; &#125; static deferred() &#123; const dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd; &#125;&#125;module.exports = Promise; 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// test.js&apos;use strict&apos;;const Promise = require(&apos;./Promise&apos;);// 测试1 - 同步触发resolve&#123; new Promise((resolve, reject) =&gt; &#123; resolve(1); &#125;).then( data =&gt; &#123; console.log(data); // 1 &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; );&#125;// 测试2 - 异步触发resolve&#123; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 1000); &#125;).then( data =&gt; &#123; console.log(data); // 2 &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; );&#125;// 测试3 - 注册多个then函数&#123; var promise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(3); &#125;, 2000); &#125;); promise3.then( data =&gt; &#123; console.log(data); // 3 return data + &apos;c&apos;; &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; ); promise3.then( data =&gt; &#123; console.log(data); // 3 &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; );&#125;// 测试4 - executor执行报错&#123; new Promise((resolve, reject) =&gt; &#123; a.b = 10; resolve(4); &#125;).then( data =&gt; &#123; console.log(data); // error: ReferenceError: a is not defined &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; );&#125;// 测试5 - 主动执行reject&#123; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&apos;5 error&apos;); &#125;, 1000); &#125;).then( data =&gt; &#123; console.log(data); &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); // error: 5 error &#125; );&#125;// 测试6 - 链式调用，then函数返回值是一个新Promise&#123; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(6); &#125;, 3000); &#125;).then( data =&gt; &#123; console.log(data); // 6 return new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve, reject) =&gt; &#123; resolve(&apos;new 6&apos;); &#125;)); &#125;) &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; ).then( data =&gt; &#123; console.log(&apos;then返回新Promise的数据&apos;, data); // then返回新Promise的数据 new 6 &#125;, error =&gt; &#123; console.log(&apos;then返回新Promise的error&apos;, error); &#125; );&#125;// 测试7 - 就算马上调用resolve，Promise也始终是异步调用，微队列micro task，也叫jobs，宏队列macro task，又叫tasks&#123; console.log(&apos;执行1&apos;); var promise7 = new Promise((resolve, reject) =&gt; &#123; resolve(7); &#125;); promise7.then( data =&gt; &#123; console.log(&apos;执行3&apos;) // 执行3 console.log(data); // 7 &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; ); promise7.then( data =&gt; &#123; console.log(&apos;执行4&apos;) // 执行4 console.log(data); // 7 &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; ); console.log(&apos;执行2&apos;)&#125;// 测试8 - Promise.all 和 Promise.race&#123; let promise8_1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;8-1&apos;); &#125;, 1000); &#125;); let promise8_2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;8-2&apos;); &#125;, 2000); &#125;); let promise8_3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;8-3&apos;); &#125;, 3000); &#125;); Promise.all([promise8_1, promise8_2, promise8_3]) .then( data =&gt; &#123; console.log(data); // [ &apos;8-1&apos;, &apos;8-2&apos;, &apos;8-3&apos; ] &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; ); Promise.race([promise8_1, promise8_2, promise8_3]) .then( data =&gt; &#123; console.log(data); // 8-1 &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; );&#125;// 测试9 - Promise穿透&#123; new Promise((resolve, reject) =&gt; &#123; resolve(9); &#125;) .then() .then( data =&gt; &#123; console.log(data); // 9 &#125;, error =&gt; &#123; console.log(&apos;error: &apos;, error); &#125; );&#125;// 测试10 - catch()&#123; new Promise((resolve, reject) =&gt; &#123; reject(10); &#125;).then(data =&gt; &#123; console.log(data); &#125;).catch(error =&gt; &#123; // 这里catch其实是一个新的Promise的then // 上一个Promise有默认的onRejected函数，做的是 throw reason，所以then返回的Promise就捕获到了错误 // 执行reject(reason)，然后返回的这个Promise就进入错误处理函数，把第一个Promise的错误reason打印出来 // 原理就是第一个Promise的错误reason被throw出来，被下一个Promise捕获到 console.log(&apos;error: &apos;, error); // error: 10 &#125;);&#125;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://roy-cook.tech/categories/Web前端/"},{"name":"JavaScript","slug":"Web前端/JavaScript","permalink":"https://roy-cook.tech/categories/Web前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://roy-cook.tech/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://roy-cook.tech/tags/Web前端/"}]},{"title":"关于博客搭建","slug":"开篇博客","date":"2018-09-04T05:38:44.000Z","updated":"2021-06-25T07:44:13.721Z","comments":true,"path":"博客搭建/posts/53510.html","link":"","permalink":"https://roy-cook.tech/博客搭建/posts/53510.html","excerpt":"开个博客，写写东西。","text":"开个博客，写写东西。 很早之前就想建一个博客来写点东西，毕竟已经很久没有写过文章了，所以现在再提笔显得十分生涩，不像几年前那样能随意自在。 搭建博客是很简单的，但是想坚持下来就没那么容易了。立个flag，希望自己能够坚持写博客，发文章，不管是技术教程，还是解决了哪一些问题，亦或是旅途中的美景、人生感悟都可以，希望能坚持到毕业。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://roy-cook.tech/categories/博客搭建/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://roy-cook.tech/tags/博客搭建/"}]}],"categories":[{"name":"APP","slug":"APP","permalink":"https://roy-cook.tech/categories/APP/"},{"name":"React Native","slug":"APP/React-Native","permalink":"https://roy-cook.tech/categories/APP/React-Native/"},{"name":"WEB安全","slug":"WEB安全","permalink":"https://roy-cook.tech/categories/WEB安全/"},{"name":"SSL","slug":"WEB安全/SSL","permalink":"https://roy-cook.tech/categories/WEB安全/SSL/"},{"name":"版本控制","slug":"版本控制","permalink":"https://roy-cook.tech/categories/版本控制/"},{"name":"Git","slug":"版本控制/Git","permalink":"https://roy-cook.tech/categories/版本控制/Git/"},{"name":"Node.js","slug":"Node-js","permalink":"https://roy-cook.tech/categories/Node-js/"},{"name":"前端自动化","slug":"前端自动化","permalink":"https://roy-cook.tech/categories/前端自动化/"},{"name":"前端工程化","slug":"前端自动化/前端工程化","permalink":"https://roy-cook.tech/categories/前端自动化/前端工程化/"},{"name":"持续集成","slug":"前端自动化/前端工程化/持续集成","permalink":"https://roy-cook.tech/categories/前端自动化/前端工程化/持续集成/"},{"name":"自动化","slug":"自动化","permalink":"https://roy-cook.tech/categories/自动化/"},{"name":"持续集成","slug":"自动化/持续集成","permalink":"https://roy-cook.tech/categories/自动化/持续集成/"},{"name":"Web前端","slug":"Web前端","permalink":"https://roy-cook.tech/categories/Web前端/"},{"name":"JavaScript","slug":"Web前端/JavaScript","permalink":"https://roy-cook.tech/categories/Web前端/JavaScript/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://roy-cook.tech/categories/博客搭建/"}],"tags":[{"name":"APP","slug":"APP","permalink":"https://roy-cook.tech/tags/APP/"},{"name":"React Native","slug":"React-Native","permalink":"https://roy-cook.tech/tags/React-Native/"},{"name":"SSL","slug":"SSL","permalink":"https://roy-cook.tech/tags/SSL/"},{"name":"版本控制","slug":"版本控制","permalink":"https://roy-cook.tech/tags/版本控制/"},{"name":"Git","slug":"Git","permalink":"https://roy-cook.tech/tags/Git/"},{"name":"Node.js","slug":"Node-js","permalink":"https://roy-cook.tech/tags/Node-js/"},{"name":"前端自动化","slug":"前端自动化","permalink":"https://roy-cook.tech/tags/前端自动化/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://roy-cook.tech/tags/前端工程化/"},{"name":"持续集成","slug":"持续集成","permalink":"https://roy-cook.tech/tags/持续集成/"},{"name":"自动化","slug":"自动化","permalink":"https://roy-cook.tech/tags/自动化/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://roy-cook.tech/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://roy-cook.tech/tags/Web前端/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://roy-cook.tech/tags/博客搭建/"}]}